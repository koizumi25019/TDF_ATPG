//------------------------------------------------------------------------
//インクルード
//------------------------------------------------------------------------
#include <stdio.h>
#include <time.h>
#include<stdlib.h>
#include<string.h>

//------------------------------------------------------------------------
//自作インクルード
//------------------------------------------------------------------------
#include"../Header/Define.h"

//===================================================
//関数名:specific_fault_range
//機能:故障範囲特定
//戻り値：int 正常終了:SUCCESS(=0) , 異常終了:ERROR(=-1)
//引数：故障信号線名
//===================================================
int specific_fault_range(char* name) {
	int i;
	NLIST* nlist;

	fc_ppo = 0;//PPO数初期化

	//-----------------------------------------------
	//	故障回路の添え字初期化			   
	//-----------------------------------------------
	for (i = 0; i < n_net; i++) {
		nl[i].suf_fc = nl[i].suf_2t; //2時刻目の添え字で初期化
	}
	//-----------------------------------------------				
	//	故障回路のFAULT_PASS初期化
	//-----------------------------------------------
	for (i = 0; i < n_net; i++) { 
		nl[i].fault_pass = NO;
	}

	//---------------------------------------------------------------------
	//故障範囲の特定
	//---------------------------------------------------------------------
	//-----------------------------------------------
	//故障範囲特定
	//-----------------------------------------------
	for (i = 0; i < n_net; i++) {
		if (strcmp(name, nl[i].name) == 0) {
			enqueue(&nl[i], 0);
			break;
		}
	}
	//-----------------------------------------------
	//故障信号線から到達可能な信号線の探索
	//-----------------------------------------------
	//到達可能：ある信号線がほかの信号線に影響を与える可能性があるかどうかを意味する
	//どの信号線に影響が広がっていくかを正確に特定することで、冗長故障の削除やテストパターン生成の範囲を絞り込むことができる
	while (queue_emp() != 0) {
		nlist = dequeue();		//デキュー
		nlist->fault_pass = YES;//故障到達可能な信号線に設定
		nlist->suf_fc = suffix;	//故障回路の添え字設定
		suffix++;				//添え字インクリメント
		if (nlist->ppo_flag != 1) {//回路の最後の信号線ではないか判断していると思う
			for (i = 0; i < nlist->n_out; i++) {//複数の出力なら、それぞれエンキュー
				if (nlist->out[i]->fault_pass == NO) enqueue(nlist->out[i], 0);
			}
		}
	}

	//故障回路に含まれるPPO数算出
	for (i = 0; i < n_net; i++) {
		if (nl[i].fault_pass == YES && nl[i].ppo_flag == 1) fc_ppo++;
	}

	return SUCCESS;
}